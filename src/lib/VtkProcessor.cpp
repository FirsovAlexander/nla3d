// This file is a part of nla3d project. For information about authors and
// licensing go to project's repository on github:
// https://github.com/dmitryikh/nla3d 

#include "VtkProcessor.h"
#include "elements/element.h"

namespace nla3d {
using namespace math;

VtkProcessor::VtkProcessor(FEStorage *st, std::string _fileName) : PostProcessor(st) {
	name = "VtkProcessor";
	file_name = _fileName;
}

VtkProcessor::~VtkProcessor() {
}

void VtkProcessor::pre() {
	std::string cur_fn = file_name + "0"  + ".vtk";
	std::ofstream file(cur_fn.c_str(), std::ios::trunc);
	write_header(file);
	write_geometry(file);
	write_point_data(file);
	write_cell_data(file);
	file.close();
}

void VtkProcessor::process (uint16 curLoadstep) {
	std::string cur_fn = file_name + toStr(curLoadstep) + ".vtk";
	std::ofstream file(cur_fn.c_str(), std::ios::trunc);
	write_header(file);
	write_geometry(file);
	write_point_data(file);
	write_cell_data(file);
	file.close();
}

void VtkProcessor::post (uint16 curLoadstep) {
}

void VtkProcessor::write_header (std::ofstream &file) {
	file << "# vtk DataFile Version 2.0" << std::endl;
	file << "This file is generated by NLA program" << std::endl << "ASCII" << std::endl;
	file << "DATASET UNSTRUCTURED_GRID" << std::endl;
}

void VtkProcessor::write_geometry(std::ofstream &file, bool def) {
	Vec<3> xi;
	file << "POINTS " << storage->getNumberOfNodes() << " float" << std::endl;
	for (uint32 i=1; i <= storage->getNumberOfNodes(); i++)
	{
		storage->getNodePosition(i, xi.ptr(), def);
		file << xi << std::endl;
	}
	/*
	CELLS en en*9
	4 i j k l

	CELL_TYPES en
	11
	11
  */

	file << "CELLS " << storage->getNumberOfElements() << " " <<  storage->getNumberOfElements()*(Element::n_nodes()+1) << std::endl;
	for (uint32 i=1; i <= storage->getNumberOfElements(); i++)
	{
    uint16 nodesNum = storage->getElement(i).n_nodes();
		file << nodesNum;
		for (uint16 j=0; j < nodesNum; j++) 
			file << " " << storage->getElement(i).getNodeNumber(j)-1;
		file << std::endl;
	}
	file << "CELL_TYPES " << storage->getNumberOfElements() << std::endl;
	for (uint32 i=1; i <= storage->getNumberOfElements(); i++) {
    uint16 nodesNum = storage->getElement(i).n_nodes();
    if (nodesNum == 4) {
      file << "9" << std::endl; //VTK_QUAD, see VTK file formats
    } else if (nodesNum == 8) {
      file << "12" << std::endl; //VTK_HEXAHEDRON
    } else if (nodesNum == 2) {
      file << "3" << std::endl;
    } else {
      LOG_N_TIMES(10, ERROR) << "Don't now what type of elements here it is (el_num = " << i << ")";
    }
  }
}

void VtkProcessor::write_point_data(std::ofstream &file) {
  size_t nn = storage->getNumberOfNodes();
  file << "POINT_DATA " << nn << std::endl;
  std::vector<Vec<3> > dataVector;
  std::vector<double> dataScalar;
  dataVector.assign(nn, Vec<3> ());
  for (uint32 j = 1; j <= nn; j++) {
    if (storage->isDofUsed(j, Dof::UX)) {
      dataVector[j-1][0] = storage->getDofSolution(j, Dof::UX);
    }
    if (storage->isDofUsed(j, Dof::UY)) {
      dataVector[j-1][1] = storage->getDofSolution(j, Dof::UY);
    }
    if (storage->isDofUsed(j, Dof::UZ)) {
      dataVector[j-1][2] = storage->getDofSolution(j, Dof::UZ);
    }
  }
  writeVector(file, "disp", dataVector);

  for (uint32 j = 1; j <= nn; j++) {
    dataVector[j-1][0] = storage->getReaction(j, Dof::UX);
    dataVector[j-1][1] = storage->getReaction(j, Dof::UY);
    dataVector[j-1][2] = storage->getReaction(j, Dof::UZ);
  }
  writeVector(file, "reaction", dataVector);

  dataVector.clear();
}

//Write cell data averaging from all integration points.
//Use global coordinate system. all futher transformations 
//should be done on paraview side. 
void VtkProcessor::write_cell_data(std::ofstream &file) {
  size_t en = storage->getNumberOfElements();
  std::vector<MatSym<3> > dataTensor;
  std::vector<Vec<3> > dataVector;
  std::vector<double> dataScalar;

  // if queries are empty - no cell data to be stored into VTK
  if (cellScalarQuery.size() == 0 && cellVectorQuery.size() == 0 && cellTensorQuery.size() == 0) {
    return;
  }
	file << "CELL_DATA " << en << std::endl;
  
  if (cellScalarQuery.size() > 0) {
    dataScalar.assign(en, 0.0);
    for (size_t j = 0; j < cellScalarQuery.size(); j++) {
      for (uint32 i = 1; i <= storage->getNumberOfElements(); i++) {
        dataScalar[i-1] = 0.0;
        storage->getElement(i).getScalar(dataScalar[i-1], cellScalarQuery[j]);
      }
      writeScalar(file, query::scalarQueryLabels[cellScalarQuery[j]], dataScalar); 
    }
    dataScalar.clear();
  }

  if (cellVectorQuery.size() > 0) {
    dataVector.assign(en, Vec<3> ());
    for (size_t j = 0; j < cellVectorQuery.size(); j++) {
      for (uint32 i = 1; i <= storage->getNumberOfElements(); i++) {
        dataVector[i-1].zero();
        storage->getElement(i).getVector(dataVector[i-1].ptr(), cellVectorQuery[j]);
      }
      writeVector (file, query::vectorQueryLabels[cellVectorQuery[j]], dataVector); 
    }
    dataVector.clear();
  }

  if (cellTensorQuery.size() > 0) {
    dataTensor.assign(en, MatSym<3> ());
    for (size_t j = 0; j < cellTensorQuery.size(); j++) {
      for (uint32 i = 1; i <= storage->getNumberOfElements(); i++) {
        dataTensor[i-1].zero();
        storage->getElement(i).getTensor(dataTensor[i-1], cellTensorQuery[j]);
      }
      writeTensor (file, query::tensorQueryLabels[cellTensorQuery[j]], dataTensor); 
    }
    dataTensor.clear();
  }
}


void VtkProcessor::writeScalar(std::ofstream &file, const char* name, std::vector<double>& data) {
  file << "SCALARS " << name <<  " float 1" << std::endl;
  file << "LOOKUP_TABLE default"<< std::endl;
  for (size_t i = 0; i < data.size(); i++) {
    file << data[i] << std::endl;
  }
  file << std::endl;
}


void VtkProcessor::writeTensor(std::ofstream &file, const char* name, std::vector<MatSym<3> >& data) {
    for (size_t j = 0; j < 6; j++) {
      file << "SCALARS " << name << "_" << solidmech::labelsTensorComponent[j] << " float 1" << std::endl;
      file << "LOOKUP_TABLE default"<< std::endl;
      for (size_t i = 0; i < data.size(); i++) {
        file << data[i].data[j] << std::endl;
      }
      file << std::endl;
    }
}


void VtkProcessor::writeVector(std::ofstream &file, const char* name, std::vector<Vec<3> >& data) {
  file << "VECTORS " << name << " float" << std::endl;
  for (size_t i = 0; i < data.size(); i++) {
    file << data[i] << std::endl;
  }
  file << std::endl;

}

} // namespace nla3d
