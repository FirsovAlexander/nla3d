#include "vtk_proc.h"

Vtk_proc::Vtk_proc(FE_Storage_Interface *st, string _fileName) : Post_proc(st)
{
	name = "Vtk_processor";
	file_name = _fileName;
	comp_codes.push_back(E_1);
	comp_codes.push_back(E_2);
	comp_codes.push_back(E_3);
	comp_codes.push_back(E_VOL);
	comp_codes.push_back(S_1);
	comp_codes.push_back(S_2);
	comp_codes.push_back(S_3);
	comp_codes.push_back(S_P);
}

Vtk_proc::~Vtk_proc()
{
}

void Vtk_proc::pre(uint16 qLoadstep)
{
	string cur_fn = file_name +  IntToStr(0) + ".vtk";
	ofstream file(cur_fn, ios::trunc);
	write_header(file);
	write_geometry(file, false);
	write_point_data(file, true);
	write_cell_data(file,true);
	file.close();
}

void Vtk_proc::process (uint16 curLoadstep, uint16 qLoadstep)
{
	string cur_fn = file_name +  IntToStr(curLoadstep) + ".vtk";
	ofstream file(cur_fn, ios::trunc);
	write_header(file);
	write_geometry(file, false);
	write_point_data(file, false);
	write_cell_data(file,false);
	file.close();
}

void Vtk_proc::post (uint16 curLoadstep, uint16 qLoadstep)
{
}

void Vtk_proc::write_header (ofstream &file)
{
	file << "# vtk DataFile Version 2.0" << endl;
	file << "This file is generated by NLA program" << endl << "ASCII" << endl;
	file << "DATASET UNSTRUCTURED_GRID" << endl;
}

void Vtk_proc::write_geometry(ofstream &file, bool def)
{
	Vec<3> xi;
	file << "POINTS " << storage->getNumNode() << " float" << endl;
	for (uint32 i=1; i <= storage->getNumNode(); i++)
	{
		storage->get_node_pos(i, xi.ptr(), def);
		file << xi << endl;
	}
	/*
	CELLS en en*9
	4 i j k l

	CELL_TYPES en
	11
	11

	CELL_DATA en
	TENSORS Couchy_stresses float
	t11 t12 t13
	..  ..  ..
	t31 t32 t33
	*/

	file << "CELLS " << storage->getNumElement() << " " <<  storage->getNumElement()*(Element::n_nodes()+1) << endl;
	for (uint32 i=1; i <= storage->getNumElement(); i++)
	{
    uint16 nodesNum = storage->getElement(i).n_nodes();
		file << nodesNum;
		for (uint16 j=0; j < nodesNum; j++) 
			file << " " << storage->getElement(i).node_num(j)-1;
		file << endl;
	}
	file << "CELL_TYPES " << storage->getNumElement() << endl;
	for (uint32 i=1; i <= storage->getNumElement(); i++) {
    uint16 nodesNum = storage->getElement(i).n_nodes();
    if (nodesNum == 4) {
      file << "9" << endl; //VTK_QUAD, see VTK file formats
    } else if (nodesNum == 8) {
      file << "12" << endl; //VTK_HEXAHEDRON
    } else {
      error("I don't now what type of elements here it is (el_num = %d)", i);
    }
  }
}

void Vtk_proc::write_point_data(ofstream &file, bool zero)
{
	double val, tmp;
	file << "POINT_DATA " << storage->getNumNode() << endl;
	char* ux_labels[] = {"ux", "uy", "uz"};
	for (uint16 i=0; i < Element::n_dim(); i++) //TODO: alawys write 3 coordinates
	{
		file << "SCALARS " << ux_labels[i] << " float 1" << endl;
		file << "LOOKUP_TABLE default"<< endl;
		for (uint32 j=1; j <= storage->getNumNode(); j++)
			if (zero)
				file << 0.0 << endl;
			else
				file << storage->get_qi_n(j, i) << endl;
	}
}

//Write cell data averaging from all integration points.
//Use global coordinate system. all futher transformations 
//should be done on paraview side. 
void Vtk_proc::write_cell_data(ofstream &file, bool zero)
{
	file << "CELL_DATA " << storage->getNumElement() << endl;
  MatSym<3> data;

  // tensor couchy [T]
	file << "TENSORS " << "T" << " float" << endl;
  if (zero) {
    for (uint32 i=1; i <= storage->getNumElement(); i++) {
      file << "0 0 0" << endl;
      file << "0 0 0" << endl;
      file << "0 0 0" << endl << endl;
    }
  } else {
    for (uint32 i=1; i <= storage->getNumElement(); i++) {
      data.zeros();
      storage->getElement(i).getTensor(data, TENS_COUCHY);
      file << data.data[0] << " " << data.data[1] << " " << data.data[2] << endl;
      file << data.data[1] << " " << data.data[3] << " " << data.data[4] << endl;
      file << data.data[2] << " " << data.data[4] << " " << data.data[5] << endl << endl;
    }
  }
  
  // tensor [E]
	file << "TENSORS " << "E" << " float" << endl;
  if (zero) {
    for (uint32 i=1; i <= storage->getNumElement(); i++) {
      file << "0 0 0" << endl;
      file << "0 0 0" << endl;
      file << "0 0 0" << endl << endl;
    }
  } else {
    for (uint32 i=1; i <= storage->getNumElement(); i++) {
      data.zeros();
      storage->getElement(i).getTensor(data, TENS_E);
      file << data.data[0] << " " << data.data[1] << " " << data.data[2] << endl;
      file << data.data[1] << " " << data.data[3] << " " << data.data[4] << endl;
      file << data.data[2] << " " << data.data[4] << " " << data.data[5] << endl << endl;
    }
  }

  // hydrostatic pressure
  file << "SCALARS " << "SP" << " float 1" << endl;
  file << "LOOKUP_TABLE default"<< endl;
  if (zero) {
    for (uint32 i=1; i <= storage->getNumElement(); i++) {
      file << "0" << endl;
    }
  } else {
    for (uint32 i=1; i <= storage->getNumElement(); i++) {
      double val;
      storage->getElement(i).getScalar(val, S_P);
      file << val << endl;
    }
  }
  file << endl;
}
