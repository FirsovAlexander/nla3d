// This file is a part of nla3d project. For information about authors and
// licensing go to project's repository on github:
// https://github.com/dmitryikh/nla3d 

#include "VtkProcessor.h"

namespace nla3d {
using namespace math;

VtkProcessor::VtkProcessor(FEStorage *st, std::string _fileName) : PostProcessor(st)
{
	name = "VtkProcessor";
	file_name = _fileName;
}

VtkProcessor::~VtkProcessor()
{
}

void VtkProcessor::pre(uint16 qLoadstep)
{
	std::string cur_fn = file_name + "0"  + ".vtk";
	std::ofstream file(cur_fn.c_str(), std::ios::trunc);
	write_header(file);
	write_geometry(file);
	write_point_data(file);
	write_cell_data(file);
	file.close();
}

void VtkProcessor::process (uint16 curLoadstep, uint16 qLoadstep)
{
	std::string cur_fn = file_name + toStr(curLoadstep) + ".vtk";
	std::ofstream file(cur_fn.c_str(), std::ios::trunc);
	write_header(file);
	write_geometry(file);
	write_point_data(file);
	write_cell_data(file);
	file.close();
}

void VtkProcessor::post (uint16 curLoadstep, uint16 qLoadstep)
{
}

void VtkProcessor::write_header (std::ofstream &file)
{
	file << "# vtk DataFile Version 2.0" << std::endl;
	file << "This file is generated by NLA program" << std::endl << "ASCII" << std::endl;
	file << "DATASET UNSTRUCTURED_GRID" << std::endl;
}

void VtkProcessor::write_geometry(std::ofstream &file, bool def)
{
	Vec<3> xi;
	file << "POINTS " << storage->getNumberOfNodes() << " float" << std::endl;
	for (uint32 i=1; i <= storage->getNumberOfNodes(); i++)
	{
		storage->getNodePosition(i, xi.ptr(), def);
		file << xi << std::endl;
	}
	/*
	CELLS en en*9
	4 i j k l

	CELL_TYPES en
	11
	11

	CELL_DATA en
	TENSORS Couchy_stresses float
	t11 t12 t13
	..  ..  ..
	t31 t32 t33
	*/

	file << "CELLS " << storage->getNumberOfElements() << " " <<  storage->getNumberOfElements()*(Element::n_nodes()+1) << std::endl;
	for (uint32 i=1; i <= storage->getNumberOfElements(); i++)
	{
    uint16 nodesNum = storage->getElement(i).n_nodes();
		file << nodesNum;
		for (uint16 j=0; j < nodesNum; j++) 
			file << " " << storage->getElement(i).getNodeNumber(j)-1;
		file << std::endl;
	}
	file << "CELL_TYPES " << storage->getNumberOfElements() << std::endl;
	for (uint32 i=1; i <= storage->getNumberOfElements(); i++) {
    uint16 nodesNum = storage->getElement(i).n_nodes();
    if (nodesNum == 4) {
      file << "9" << std::endl; //VTK_QUAD, see VTK file formats
    } else if (nodesNum == 8) {
      file << "12" << std::endl; //VTK_HEXAHEDRON
    } else {
      error("I don't now what type of elements here it is (el_num = %d)", i);
    }
  }
}

void VtkProcessor::write_point_data(std::ofstream &file, bool zero)
{
  size_t nn = storage->getNumberOfNodes();
  file << "POINT_DATA " << nn << std::endl;
  std::vector<Vec<3> > dataVector;
  std::vector<double> dataScalar;
  if (zero) {
    //writeZeroVector(file, "disp", nn);
  } else {
    dataVector.assign(nn, Vec<3> ());
    for (uint32 j = 1; j <= nn; j++) {
      if (storage->isDofUsed(j, Dof::UX)) {
        dataVector[j-1][0] = storage->getDofSolution(j, Dof::UX);
      }
      if (storage->isDofUsed(j, Dof::UY)) {
        dataVector[j-1][1] = storage->getDofSolution(j, Dof::UY);
      }
      if (storage->isDofUsed(j, Dof::UZ)) {
        dataVector[j-1][2] = storage->getDofSolution(j, Dof::UZ);
      }
    }
    writeVector(file, "disp", dataVector);

    for (uint32 j = 1; j <= nn; j++) {
      dataVector[j-1][0] = storage->getReaction(j, Dof::UX);
      dataVector[j-1][1] = storage->getReaction(j, Dof::UY);
      dataVector[j-1][2] = storage->getReaction(j, Dof::UZ);
    }
    writeVector(file, "reaction", dataVector);

    

    dataVector.clear();

  }
}

//Write cell data averaging from all integration points.
//Use global coordinate system. all futher transformations 
//should be done on paraview side. 
void VtkProcessor::write_cell_data(std::ofstream &file, bool zero) {
  size_t en = storage->getNumberOfElements();
  std::vector<MatSym<3> > dataTensor;
  std::vector<Vec<3> > dataVector;
  std::vector<double> dataScalar;
  std::vector<double> dataScalar2;
  std::vector<double> dataScalar3;
  std::vector<double> dataScalar4;

	file << "CELL_DATA " << en << std::endl;
  
  dataTensor.assign(en , MatSym<3>() );
  // tensor couchy [T]
  // fill data
  for (uint32 i = 1; i <= en; i++) {
    dataTensor[i-1].zeros();
    storage->getElement(i).getTensor(dataTensor[i-1], query::TENSOR_COUCHY);
  }
  //write data
  writeTensor(file, query::tensorQueryLabels[query::TENSOR_COUCHY], dataTensor);

  // tensor [E]
  // fill data
  for (uint32 i = 1; i <= en; i++) {
    dataTensor[i-1].zeros();
    storage->getElement(i).getTensor(dataTensor[i-1], query::TENSOR_E);
  }
  //write data
  writeTensor(file, query::tensorQueryLabels[query::TENSOR_E], dataTensor);

  //clear memore from tensor data
  dataTensor.clear();


  dataScalar.assign(en, double() );
  dataScalar2.assign(en, double() );
  dataScalar3.assign(en, double() );
  dataScalar4.assign(en, double() );
  // Invariants IC
  // fill data
  double tmp[3];
  for (uint32 i = 1; i <= en; i++) {
    tmp[0] = 0.0;
    tmp[1] = 0.0;
    tmp[2] = 0.0;
    storage->getElement(i).getVector(tmp, query::VECTOR_IC);
    dataScalar[i-1] = tmp[0];
    dataScalar2[i-1] = tmp[1];
    dataScalar3[i-1] = tmp[2];
  }
  //write data
  writeScalar(file, "IC_1", dataScalar); 
  writeScalar(file, "IC_2", dataScalar2); 
  writeScalar(file, "IC_3", dataScalar3); 

  //clear data
  dataScalar2.clear();
  dataScalar3.clear();

  // hydrostatic pressure
  for (uint32 i = 1; i <= storage->getNumberOfElements(); i++) {
    dataScalar[i-1] = 0.0;
    storage->getElement(i).getScalar(dataScalar[i-1], query::SCALAR_SP);
  }
  writeScalar(file, query::scalarQueryLabels[query::SCALAR_SP], dataScalar); 

  // isohorit energy density Wu
  for (uint32 i = 1; i <= storage->getNumberOfElements(); i++) {
    dataScalar[i-1] = 0.0;
    storage->getElement(i).getScalar(dataScalar[i-1], query::SCALAR_WU);
  }
  writeScalar(file, query::scalarQueryLabels[query::SCALAR_WU], dataScalar); 

  // volumetric energy density Wp
  for (uint32 i = 1; i <= storage->getNumberOfElements(); i++) {
    dataScalar[i-1] = 0.0;
    storage->getElement(i).getScalar(dataScalar[i-1], query::SCALAR_WP);
  }
  writeScalar(file, query::scalarQueryLabels[query::SCALAR_WP], dataScalar); 


  for (uint32 j = 1; j <= en; j++) {
    dataScalar[j-1] = 0.0;
    storage->getElement(j).getScalar(dataScalar[j-1], query::SCALAR_VOL, 0);
  }
  writeScalar(file, query::scalarQueryLabels[query::SCALAR_VOL], dataScalar);

  //clear data
  dataScalar.clear();
}


void VtkProcessor::writeScalar(std::ofstream &file, const char* name, std::vector<double>& data) {
  file << "SCALARS " << name <<  " float 1" << std::endl;
  file << "LOOKUP_TABLE default"<< std::endl;
  for (size_t i = 0; i < data.size(); i++) {
    file << data[i] << std::endl;
  }
  file << std::endl;
}


void VtkProcessor::writeTensor(std::ofstream &file, const char* name, std::vector<MatSym<3> >& data) {
    for (size_t j = 0; j < 6; j++) {
      file << "SCALARS " << name << "_" << solidmech::labelsTensorComponent[j] << " float 1" << std::endl;
      file << "LOOKUP_TABLE default"<< std::endl;
      for (size_t i = 0; i < data.size(); i++) {
        file << data[i].data[j] << std::endl;
      }
      file << std::endl;
    }
}


void VtkProcessor::writeVector(std::ofstream &file, const char* name, std::vector<Vec<3> >& data) {
  file << "VECTORS " << name << " float" << std::endl;
  for (size_t i = 0; i < data.size(); i++) {
    file << data[i] << std::endl;
  }
  file << std::endl;

}

} // namespace nla3d
